export type UITask = {
  id: string;
  level: 'junior'|'middle'|'senior';
  title: string;
  exportName: string;
  description: string;
  starter: string;
  tests: string;
  language?: 'javascript'|'typescript'|'java'|'sql'|'yaml';
  testsSql?: {
    schema?: string[];
    data?: string[];
    expectedRows: any[];
    check?: string;
    queryVar?: string;
  };
  testsYaml?: {
    rules: { path: string; equals?: any; regex?: string; exists?: boolean; length?: number }[]
  };
  solution?: string; // Эталонное решение для интервьюера
};

/* =============== FRONTEND: 20 задач =============== */
const FE: UITask[] = [
  // --- JUNIOR (6) ---
  { 
    id: 'fe_classNames', 
    level: 'junior', 
    title: 'classNames(...inputs)', 
    exportName: 'classNames',
    description: 'Собрать классы из строк/массивов/объектов, уникально, в порядке появления.',
    starter: `export function classNames(...inputs: any[]): string {
  // TODO: Реализуйте функцию classNames
  // Принимает: строки, массивы, объекты с boolean значениями
  // Возвращает: строку с уникальными классами в порядке появления
  // Пример: classNames('a', ['b', {c: true, b: false}], {a: true}, 'c') → 'a b c'
  throw new Error('Not implemented');
}`,
    tests: `import { strict as assert } from 'assert'; 
import * as m from 'MODULE'; 
const { classNames } = m; 
assert.equal(classNames('a', ['b', {c: true, b: false}], {a: true}, 'c'), 'a b c');`,
    solution: `export function classNames(...inputs: any[]): string {
  const result: string[] = [];
  const seen = new Set<string>();
  
  for (const input of inputs) {
    if (!input) continue;
    
    if (typeof input === 'string' || typeof input === 'number') {
      const str = String(input);
      if (!seen.has(str)) {
        seen.add(str);
        result.push(str);
      }
    } else if (Array.isArray(input)) {
      const inner = classNames(...input);
      if (inner) {
        const classes = inner.split(' ');
        for (const cls of classes) {
          if (cls && !seen.has(cls)) {
            seen.add(cls);
            result.push(cls);
          }
        }
      }
    } else if (typeof input === 'object') {
      for (const [key, value] of Object.entries(input)) {
        if (value && !seen.has(key)) {
          seen.add(key);
          result.push(key);
        }
      }
    }
  }
  
  return result.join(' ');
}`
  },
  { 
    id: 'fe_isPalindrome', 
    level: 'junior', 
    title: 'isPalindrome(str)', 
    exportName: 'isPalindrome',
    description: 'Палиндром по графемам, игнорируя регистр и пробелы.',
    starter: `export function isPalindrome(str: unknown): boolean {
  // TODO: Реализуйте проверку палиндрома
  // Игнорируйте регистр и пробелы
  // Примеры: 'А роза упала на лапу Азора' → true, 'hello' → false
  throw new Error('Not implemented');
}`,
    tests: `import { strict as assert } from 'assert'; 
import * as m from 'MODULE'; 
const { isPalindrome } = m; 
assert.equal(isPalindrome('А роза упала на лапу Азора'), true); 
assert.equal(isPalindrome('hello'), false);`,
    solution: `export function isPalindrome(str: unknown): boolean {
  if (typeof str !== 'string') return false;
  
  // Нормализуем строку: убираем пробелы и приводим к нижнему регистру
  const normalized = str.replace(/\\s/g, '').toLowerCase();
  
  // Сравниваем с обратной строкой
  return normalized === normalized.split('').reverse().join('');
}`
  },
  { id:'fe_uniqueBy', level:'junior', title:'uniqueBy(arr, key)', exportName:'uniqueBy',
    description:'Уникальные по ключу (строка или коллбек).',
    starter:"export function uniqueBy<T>(arr:T[], key: keyof T | ((x:T)=>any)):T[]{ /* TODO */ throw new Error('Not implemented') }",
    tests:"import {strict as assert} from 'assert'; import * as m from 'MODULE'; const {uniqueBy}=m; const a=[{id:1},{id:1},{id:2}]; assert.deepEqual(uniqueBy(a,'id'),[{id:1},{id:2}]);",
    solution:`export function uniqueBy<T>(arr:T[], key: keyof T | ((x:T)=>any)):T[]{
  const seen = new Set()
  const result: T[] = []
  
  for (const item of arr) {
    const keyValue = typeof key === 'function' ? key(item) : item[key]
    
    if (!seen.has(keyValue)) {
      seen.add(keyValue)
      result.push(item)
    }
  }
  
  return result
}`
  },
  { id:'fe_chunk', level:'junior', title:'chunk(arr,size)', exportName:'chunk',
    description:'Разбить массив на чанки.',
    starter:"export function chunk<T>(arr:T[], size:number):T[][]{ /* TODO */ throw new Error('Not implemented') }",
    tests:"import {strict as assert} from 'assert'; import * as m from 'MODULE'; const {chunk}=m; assert.deepEqual(chunk([1,2,3,4,5],2), [[1,2],[3,4],[5]]);",
    solution:`export function chunk<T>(arr:T[], size:number):T[][]{
  if (size <= 0) return []
  
  const result: T[][] = []
  
  for (let i = 0; i < arr.length; i += size) {
    result.push(arr.slice(i, i + size))
  }
  
  return result
}`
  },
  { id:'fe_sumBy', level:'junior', title:'sumBy(arr,iteratee)', exportName:'sumBy',
    description:'Сумма по свойству или функции.',
    starter:"export function sumBy<T>(arr:T[], it: keyof T | ((x:T)=>number)):number{ /* TODO */ throw new Error('Not implemented') }",
    tests:"import {strict as assert} from 'assert'; import * as m from 'MODULE'; const {sumBy}=m; assert.equal(sumBy([{a:2},{a:3}],'a'),5);",
    solution:`export function sumBy<T>(arr:T[], it: keyof T | ((x:T)=>number)):number{
  return arr.reduce((sum, item) => {
    const value = typeof it === 'function' ? it(item) : item[it]
    return sum + (typeof value === 'number' ? value : 0)
  }, 0)
}`
  },
  { 
    id: 'fe_throttle', 
    level: 'junior', 
    title: 'throttle(fn,delay)', 
    exportName: 'throttle',
    description: 'Не чаще чем раз в delay мс (trailing=true).',
    starter: `export function throttle<T extends (...a: any[]) => any>(fn: T, delay = 200) {
  // TODO: Реализуйте функцию throttle
  // Ограничивает частоту вызовов функции
  // delay - минимальный интервал между вызовами в миллисекундах
  // trailing=true означает выполнение в конце интервала
  throw new Error('Not implemented');
}`,
    tests: `import { strict as assert } from 'assert'; 
import * as m from 'MODULE'; 
const { throttle } = m; 
let n = 0; 
const f = () => n++; 
const t = throttle(f, 10); 
t(); 
t(); 
setTimeout(() => { t(); assert.ok(n >= 2); }, 15);`,
    solution: `export function throttle<T extends (...a: any[]) => any>(fn: T, delay = 200) {
  let lastCall = 0;
  let timeoutId: NodeJS.Timeout | null = null;
  
  return function(this: any, ...args: any[]) {
    const now = Date.now();
    
    if (now - lastCall >= delay) {
      lastCall = now;
      return fn.apply(this, args);
    } else {
      if (timeoutId) clearTimeout(timeoutId);
      timeoutId = setTimeout(() => {
        lastCall = Date.now();
        fn.apply(this, args);
      }, delay - (now - lastCall));
    }
  } as T;
}`
  },

  // --- MIDDLE (7) ---
  { 
    id: 'fe_debounce', 
    level: 'middle', 
    title: 'debounce(fn,delay)', 
    exportName: 'debounce',
    description: 'Задержка последнего вызова, сохранить this/args; cancel().',
    starter: `export function debounce<T extends (...a: any[]) => any>(fn: T, delay = 200) {
  // TODO: Реализуйте функцию debounce
  // Откладывает выполнение функции до истечения delay мс после последнего вызова
  // Должна сохранять контекст (this) и аргументы
  // Должна иметь метод cancel() для отмены
  throw new Error('Not implemented');
}`,
    tests: `import { strict as assert } from 'assert'; 
import * as m from 'MODULE'; 
const { debounce } = m; 
let n = 0; 
const d = debounce(() => n++, 20); 
d(); 
d(); 
setTimeout(() => { assert.equal(n, 1); }, 30);`,
    solution: `export function debounce<T extends (...a: any[]) => any>(fn: T, delay = 200) {
  let timeoutId: NodeJS.Timeout | null = null;
  
  const debounced = function(this: any, ...args: any[]) {
    if (timeoutId) clearTimeout(timeoutId);
    timeoutId = setTimeout(() => fn.apply(this, args), delay);
  } as T & { cancel: () => void };
  
  debounced.cancel = () => {
    if (timeoutId) {
      clearTimeout(timeoutId);
      timeoutId = null;
    }
  };
  
  return debounced;
}`
  },
  { id:'fe_once', level:'middle', title:'once(fn)', exportName:'once',
    description:'Выполнить один раз, вернуть одинаковый результат далее.',
    starter:"export function once<T extends(...a:any[])=>any>(fn:T){ /* TODO */ throw new Error('Not implemented') }",
    tests:"import {strict as assert} from 'assert'; import * as m from 'MODULE'; const {once}=m; let n=0; const o=once(()=>++n); o(); o(); assert.equal(n,1);",
    solution:`export function once<T extends(...a:any[])=>any>(fn:T){
  let called = false;
  let result: any;
  
  return function(this: any, ...args: any[]) {
    if (!called) {
      called = true;
      result = fn.apply(this, args);
    }
    return result;
  } as T;
}`
  },
  { id:'fe_deepClone', level:'middle', title:'deepClone(obj)', exportName:'deepClone',
    description:'Глубокое копирование (без функций/циклов).',
    starter:"export function deepClone<T>(x:T):T{ /* TODO */ throw new Error('Not implemented') }",
    tests:"import {strict as assert} from 'assert'; import * as m from 'MODULE'; const {deepClone}=m; const a={u:{v:1}, arr:[1,2]}; const b=deepClone(a); (b as any).u.v=2; assert.equal(a.u.v,1);",
    solution:`export function deepClone<T>(x:T):T{
  if (x === null || typeof x !== 'object') return x;
  
  if (x instanceof Date) return new Date(x.getTime()) as T;
  if (x instanceof Array) return x.map(item => deepClone(item)) as T;
  if (x instanceof RegExp) return new RegExp(x.source, x.flags) as T;
  
  const cloned = {} as T;
  for (const key in x) {
    if (x.hasOwnProperty(key)) {
      cloned[key] = deepClone(x[key]);
    }
  }
  
  return cloned;
}`
  },
  { id:'fe_curry', level:'middle', title:'curry(fn)', exportName:'curry',
    description:'Каррирование функции произвольной арности.',
    starter:"export function curry(fn:Function){ /* TODO */ throw new Error('Not implemented') }",
    tests:"import {strict as assert} from 'assert'; import * as m from 'MODULE'; const {curry}=m; const add=(a:any,b:any,c:any)=>a+b+c; const cur:any=curry(add); assert.equal(cur(1)(2)(3),6);"
  },
  { id:'fe_parseQuery', level:'middle', title:'parseQueryString(qs)', exportName:'parseQueryString',
    description:'Разобрать ?a=1&b=2&a=3 → {a:[1,3],b:\"2\"}.',
    starter:"export function parseQueryString(qs:string){ /* TODO */ throw new Error('Not implemented') }",
    tests:"import {strict as assert} from 'assert'; import * as m from 'MODULE'; const {parseQueryString}=m; assert.deepEqual(parseQueryString('?a=1&b=2&a=3'), {a:['1','3'], b:'2'});"
  },
  { id:'fe_eventDelegate', level:'middle', title:'delegate(root,selector,type,handler)', exportName:'delegate',
    description:'Событие на root + .closest(selector).',
    starter:"export function delegate(root:Element, selector:string, type:string, handler:(this:Element,ev:Event)=>void){ /* TODO */ throw new Error('Not implemented') }",
    tests:"import {strict as assert} from 'assert'; import * as m from 'MODULE'; const {delegate}=m; const root=document.createElement('div'); root.innerHTML='<ul><li class=\"x\">A</li></ul>'; document.body.appendChild(root); let ok=false; const off=delegate(root,'li.x','click',function(){ ok = (this as any).classList.contains('x') }); root.querySelector('li')!.dispatchEvent(new MouseEvent('click',{bubbles:true})); off(); assert.equal(ok,true);"
  },
  { id:'fe_fetchJSON', level:'middle', title:'fetchJSON(url,{signal})', exportName:'fetchJSON',
    description:'Безопасный fetch: ok/json/ошибки/отмена.',
    starter:"export async function fetchJSON(url:string, opts:RequestInit={}){ /* TODO */ throw new Error('Not implemented') }",
    tests:"const orig=(global as any).fetch; (global as any).fetch=async (_u:any)=> new Response(JSON.stringify({ok:true}),{status:200}); import {strict as assert} from 'assert'; import * as m from 'MODULE'; const {fetchJSON}=m; const r=await fetchJSON('/ok'); assert.equal(r.ok,true); (global as any).fetch=orig;"
  },

  // --- SENIOR (7) ---
  { id:'fe_LRU', level:'senior', title:'LRUCache<K,V>', exportName:'LRUCache',
    description:'Кэш с вытеснением LRU.',
    starter:"export class LRUCache<K,V>{ /* TODO */ }",
    tests:"import {strict as assert} from 'assert'; import * as m from 'MODULE'; const {LRUCache}=m; const c:any=new LRUCache(2); c.set?.('a',1); c.set?.('b',2); c.get?.('a'); c.set?.('c',3); assert.ok(true);"
  },
  { id:'fe_deepEqual', level:'senior', title:'deepEqual(a,b)', exportName:'deepEqual',
    description:'Глубокое сравнение без циклов.',
    starter:"export function deepEqual(a:any,b:any):boolean{ /* TODO */ throw new Error('Not implemented') }",
    tests:"import {strict as assert} from 'assert'; import * as m from 'MODULE'; const {deepEqual}=m; assert.equal(deepEqual({x:[1,{y:2}]},{x:[1,{y:2}]}), true);"
  },
  { id:'fe_formatBytes', level:'senior', title:'formatBytes(n)', exportName:'formatBytes',
    description:'Форматировать байты: 1536 → \"1.5 KB\".',
    starter:"export function formatBytes(n:number):string{ /* TODO */ throw new Error('Not implemented') }",
    tests:"import {strict as assert} from 'assert'; import * as m from 'MODULE'; const {formatBytes}=m; assert.equal(formatBytes(1536),'1.5 KB');"
  },
  { id:'fe_memoize', level:'senior', title:'memoize(fn,keyFn?)', exportName:'memoize',
    description:'Кэшировать результаты по ключу.',
    starter:"export function memoize<T extends(...a:any[])=>any>(fn:T,keyFn?:(...a:any[])=>string){ /* TODO */ throw new Error('Not implemented') }",
    tests:"import {strict as assert} from 'assert'; import * as m from 'MODULE'; const {memoize}=m; let n=0; const f=(x:number)=>{n++; return x*x}; const mfn:any=memoize(f); mfn(2); mfn(2); assert.equal(n,1);"
  },
  { id:'fe_flatten', level:'senior', title:'flatten(arr,depth=Infinity)', exportName:'flatten',
    description:'Флэттенинг массива до глубины.',
    starter:"export function flatten(arr:any[], depth=Infinity):any[]{ /* TODO */ throw new Error('Not implemented') }",
    tests:"import {strict as assert} from 'assert'; import * as m from 'MODULE'; const {flatten}=m; assert.deepEqual(flatten([1,[2,[3]]],2), [1,2,[3]]);"
  },
  { id:'fe_diffShallow', level:'senior', title:'diffShallow(a,b)', exportName:'diffShallow',
    description:'Разница ключей (added/removed/changed).',
    starter:"export function diffShallow(a:any,b:any){ /* TODO */ throw new Error('Not implemented') }",
    tests:"import {strict as assert} from 'assert'; import * as m from 'MODULE'; const {diffShallow}=m; const d=diffShallow({a:1,b:2},{b:3,c:4}); assert.equal(d.added[0],'c'); assert.equal(d.removed[0],'a');"
  },
  { id:'fe_compose', level:'senior', title:'compose(...fns)', exportName:'compose',
    description:'Композиция функций справа налево.',
    starter:"export function compose(...fns:Function[]){ /* TODO */ throw new Error('Not implemented') }",
    tests:"import {strict as assert} from 'assert'; import * as m from 'MODULE'; const {compose}=m; const f=(x:number)=>x+1, g=(x:number)=>x*2; assert.equal((compose(f,g) as any)(3), f(g(3)));"
  },

  // === СОВРЕМЕННЫЕ FRONTEND ЗАДАЧИ ===
  
  // JUNIOR - Современный JavaScript
  { id:'fe_optionalChaining', level:'junior', title:'safeGet(obj, path)', exportName:'safeGet',
    description:'Безопасное получение значения по пути (a.b.c) с fallback.',
    starter:"export function safeGet(obj: any, path: string, defaultValue?: any): any { /* TODO */ throw new Error('Not implemented') }",
    tests:"import {strict as assert} from 'assert'; import * as m from 'MODULE'; const {safeGet}=m; assert.equal(safeGet({a:{b:{c:1}}}, 'a.b.c'), 1); assert.equal(safeGet({a:{b:{c:1}}}, 'a.b.d', 'default'), 'default');",
    solution:`export function safeGet(obj: any, path: string, defaultValue?: any): any {
  return path.split('.').reduce((current, key) => {
    return current && current[key] !== undefined ? current[key] : defaultValue;
  }, obj);
}`
  },
  
  { id:'fe_promiseAllSettled', level:'junior', title:'promiseAllSettled(promises)', exportName:'promiseAllSettled',
    description:'Выполнить все промисы и вернуть результаты (успешные + ошибки).',
    starter:"export async function promiseAllSettled<T>(promises: Promise<T>[]): Promise<Array<{status: 'fulfilled'|'rejected', value?: T, reason?: any}>> { /* TODO */ throw new Error('Not implemented') }",
    tests:"import {strict as assert} from 'assert'; import * as m from 'MODULE'; const {promiseAllSettled}=m; const results = await promiseAllSettled([Promise.resolve(1), Promise.reject('error')]); assert.equal(results.length, 2); assert.equal(results[0].status, 'fulfilled');",
    solution:`export async function promiseAllSettled<T>(promises: Promise<T>[]): Promise<Array<{status: 'fulfilled'|'rejected', value?: T, reason?: any}>> {
  return Promise.all(promises.map(promise => 
    promise.then(
      value => ({ status: 'fulfilled' as const, value }),
      reason => ({ status: 'rejected' as const, reason })
    )
  ));
}`
  },

  // MIDDLE - React & Hooks
  { id:'fe_useState', level:'middle', title:'useState(initial)', exportName:'useState',
    description:'Реализовать useState хук с функциональными обновлениями.',
    starter:"export function useState<T>(initial: T): [T, (value: T | ((prev: T) => T)) => void] { /* TODO */ throw new Error('Not implemented') }",
    tests:"import {strict as assert} from 'assert'; import * as m from 'MODULE'; const {useState}=m; const [count, setCount] = useState(0); setCount(5); assert.equal(count, 5); setCount(prev => prev + 1); assert.equal(count, 6);",
    solution:`export function useState<T>(initial: T): [T, (value: T | ((prev: T) => T)) => void] {
  let state = initial;
  const setState = (value: T | ((prev: T) => T)) => {
    state = typeof value === 'function' ? (value as (prev: T) => T)(state) : value;
  };
  return [state, setState];
}`
  },

  { id:'fe_useEffect', level:'middle', title:'useEffect(effect, deps?)', exportName:'useEffect',
    description:'Реализовать useEffect хук с зависимостями и cleanup.',
    starter:"export function useEffect(effect: () => void | (() => void), deps?: any[]): void { /* TODO */ throw new Error('Not implemented') }",
    tests:"import {strict as assert} from 'assert'; import * as m from 'MODULE'; const {useEffect}=m; let calls = 0; useEffect(() => { calls++; }); assert.equal(calls, 1);",
    solution:`export function useEffect(effect: () => void | (() => void), deps?: any[]): void {
  // Упрощенная реализация - в реальности нужен более сложный механизм
  const cleanup = effect();
  if (typeof cleanup === 'function') {
    // В реальности cleanup вызывается при размонтировании
  }
}`
  },

  { id:'fe_useMemo', level:'middle', title:'useMemo(fn, deps)', exportName:'useMemo',
    description:'Мемоизация вычислений с зависимостями.',
    starter:"export function useMemo<T>(fn: () => T, deps: any[]): T { /* TODO */ throw new Error('Not implemented') }",
    tests:"import {strict as assert} from 'assert'; import * as m from 'MODULE'; const {useMemo}=m; let calls = 0; const expensive = useMemo(() => { calls++; return 42; }, []); const result = useMemo(() => { calls++; return 42; }, []); assert.equal(calls, 1);",
    solution:`export function useMemo<T>(fn: () => T, deps: any[]): T {
  // Упрощенная реализация - в реальности нужен более сложный механизм
  return fn();
}`
  },

  // SENIOR - Производительность и оптимизация
  { id:'fe_virtualScroll', level:'senior', title:'VirtualScroll({items, height, itemHeight})', exportName:'VirtualScroll',
    description:'Виртуальный скролл для больших списков.',
    starter:"export class VirtualScroll { /* TODO */ }",
    tests:"import {strict as assert} from 'assert'; import * as m from 'MODULE'; const {VirtualScroll}=m; const vs = new VirtualScroll({items: Array.from({length: 1000}, (_, i) => i), height: 400, itemHeight: 20}); assert.ok(vs);",
    solution:`export class VirtualScroll {
  private items: any[];
  private height: number;
  private itemHeight: number;
  private scrollTop: number = 0;
  
  constructor({items, height, itemHeight}: {items: any[], height: number, itemHeight: number}) {
    this.items = items;
    this.height = height;
    this.itemHeight = itemHeight;
  }
  
  getVisibleItems() {
    const startIndex = Math.floor(this.scrollTop / this.itemHeight);
    const endIndex = Math.min(startIndex + Math.ceil(this.height / this.itemHeight), this.items.length);
    return this.items.slice(startIndex, endIndex);
  }
  
  setScrollTop(scrollTop: number) {
    this.scrollTop = scrollTop;
  }
}`
  },

  { id:'fe_intersectionObserver', level:'senior', title:'useIntersectionObserver(element, callback)', exportName:'useIntersectionObserver',
    description:'Хук для отслеживания видимости элемента.',
    starter:"export function useIntersectionObserver(element: Element | null, callback: (isIntersecting: boolean) => void): void { /* TODO */ throw new Error('Not implemented') }",
    tests:"import {strict as assert} from 'assert'; import * as m from 'MODULE'; const {useIntersectionObserver}=m; const div = document.createElement('div'); let visible = false; useIntersectionObserver(div, (isVisible) => { visible = isVisible; }); assert.equal(typeof visible, 'boolean');",
    solution:`export function useIntersectionObserver(element: Element | null, callback: (isIntersecting: boolean) => void): void {
  if (!element) return;
  
  const observer = new IntersectionObserver((entries) => {
    entries.forEach(entry => {
      callback(entry.isIntersecting);
    });
  });
  
  observer.observe(element);
  
  // В реальности нужен cleanup
  return () => observer.disconnect();
}`
  },

  { id:'fe_webWorker', level:'senior', title:'createWorker(script)', exportName:'createWorker',
    description:'Создание и управление Web Worker с сообщениями.',
    starter:"export function createWorker(script: string): {postMessage: (data: any) => void, onMessage: (callback: (data: any) => void) => void, terminate: () => void} { /* TODO */ throw new Error('Not implemented') }",
    tests:"import {strict as assert} from 'assert'; import * as m from 'MODULE'; const {createWorker}=m; const worker = createWorker('self.onmessage = (e) => self.postMessage(e.data * 2);'); let result = 0; worker.onMessage((data) => { result = data; }); worker.postMessage(5); setTimeout(() => { assert.equal(result, 10); }, 10);",
    solution:`export function createWorker(script: string): {postMessage: (data: any) => void, onMessage: (callback: (data: any) => void) => void, terminate: () => void} {
  const blob = new Blob([script], { type: 'application/javascript' });
  const worker = new Worker(URL.createObjectURL(blob));
  
  return {
    postMessage: (data: any) => worker.postMessage(data),
    onMessage: (callback: (data: any) => void) => {
      worker.onmessage = (e) => callback(e.data);
    },
    terminate: () => worker.terminate()
  };
}`
  },

  // Дополнительные современные задачи
  { id:'fe_asyncGenerator', level:'middle', title:'asyncGenerator(asyncFn, concurrency)', exportName:'asyncGenerator',
    description:'Генератор для асинхронных операций с ограничением concurrency.',
    starter:"export async function* asyncGenerator<T>(asyncFn: () => Promise<T>, concurrency: number): AsyncGenerator<T> { /* TODO */ throw new Error('Not implemented') }",
    tests:"import {strict as assert} from 'assert'; import * as m from 'MODULE'; const {asyncGenerator}=m; const gen = asyncGenerator(() => Promise.resolve(42), 2); const result = await gen.next(); assert.equal(result.value, 42);",
    solution:`export async function* asyncGenerator<T>(asyncFn: () => Promise<T>, concurrency: number): AsyncGenerator<T> {
  const semaphore = new Array(concurrency).fill(null);
  let index = 0;
  
  while (true) {
    if (semaphore[index % concurrency]) {
      await semaphore[index % concurrency];
    }
    
    semaphore[index % concurrency] = asyncFn();
    yield await semaphore[index % concurrency];
    index++;
  }
}`
  },

  { id:'fe_webSocket', level:'middle', title:'WebSocketManager(url)', exportName:'WebSocketManager',
    description:'Менеджер WebSocket с переподключением и обработкой ошибок.',
    starter:"export class WebSocketManager { /* TODO */ }",
    tests:"import {strict as assert} from 'assert'; import * as m from 'MODULE'; const {WebSocketManager}=m; const ws = new WebSocketManager('ws://localhost:8080'); assert.ok(ws);",
    solution:`export class WebSocketManager {
  private ws: WebSocket | null = null;
  private url: string;
  private reconnectAttempts = 0;
  private maxReconnectAttempts = 5;
  
  constructor(url: string) {
    this.url = url;
    this.connect();
  }
  
  private connect() {
    this.ws = new WebSocket(this.url);
    
    this.ws.onopen = () => {
      this.reconnectAttempts = 0;
    };
    
    this.ws.onclose = () => {
      if (this.reconnectAttempts < this.maxReconnectAttempts) {
        setTimeout(() => {
          this.reconnectAttempts++;
          this.connect();
        }, 1000 * this.reconnectAttempts);
      }
    };
  }
  
  send(data: any) {
    if (this.ws?.readyState === WebSocket.OPEN) {
      this.ws.send(JSON.stringify(data));
    }
  }
  
  onMessage(callback: (data: any) => void) {
    if (this.ws) {
      this.ws.onmessage = (event) => {
        callback(JSON.parse(event.data));
      };
    }
  }
}`
  },
];

/* =============== BACKEND-JAVA: 20 задач =============== */
const BE: UITask[] = [
  // JUNIOR (6)
  {id:"be_twoSum",level:"junior",title:"twoSum(nums,target)",exportName:"twoSum",description:"Индексы двух чисел с суммой target (O(n) через Map).",starter:`public class TwoSum {
  public static int[] twoSum(int[] nums, int target) {
    // TODO: реализуйте поиск двух чисел с суммой target
    return new int[]{};
  }
  
  public static void main(String[] args) {
    int[] result = twoSum(new int[]{2,7,11,15}, 9);
    System.out.println(java.util.Arrays.toString(result));
  }
}`,tests:"import {strict as assert} from 'assert'; import * as m from 'MODULE'; const {twoSum}=m; assert.deepEqual(twoSum([2,7,11,15],9),[0,1]); assert.deepEqual(twoSum([3,2,4],6),[1,2]);",language:"java",solution:`public class TwoSum {
  public static int[] twoSum(int[] nums, int target) {
    java.util.Map<Integer, Integer> map = new java.util.HashMap<>();
    
    for (int i = 0; i < nums.length; i++) {
      int complement = target - nums[i];
      
      if (map.containsKey(complement)) {
        return new int[]{map.get(complement), i};
      }
      
      map.put(nums[i], i);
    }
    
    throw new RuntimeException("No solution found");
  }
  
  public static void main(String[] args) {
    int[] result = twoSum(new int[]{2,7,11,15}, 9);
    System.out.println(java.util.Arrays.toString(result));
  }
}`},
  {id:"be_isPalindromeNum",level:"junior",title:"isPalindromeNum(x)",exportName:"isPalindromeNum",description:"Число-палиндром без преобразования в строку.",starter:`public class PalindromeNumber {
  public static boolean isPalindromeNum(int x) {
    // TODO: реализуйте проверку палиндрома без преобразования в строку
    return false;
  }
  
  public static void main(String[] args) {
    System.out.println(isPalindromeNum(121)); // true
    System.out.println(isPalindromeNum(-121)); // false
  }
}`,tests:"import {strict as assert} from 'assert'; import * as m from 'MODULE'; const {isPalindromeNum}=m; assert.equal(isPalindromeNum(121),true); assert.equal(isPalindromeNum(-121),false); assert.equal(isPalindromeNum(10),false);",language:"java",solution:`public class PalindromeNumber {
  public static boolean isPalindromeNum(int x) {
    if (x < 0) return false;
    if (x < 10) return true;
    
    int original = x;
    int reversed = 0;
    
    while (x > 0) {
      reversed = reversed * 10 + x % 10;
      x = x / 10;
    }
    
    return original == reversed;
  }
  
  public static void main(String[] args) {
    System.out.println(isPalindromeNum(121)); // true
    System.out.println(isPalindromeNum(-121)); // false
  }
}`},
  {id:"be_validParentheses",level:"junior",title:"validParentheses(s)",exportName:"validParentheses",description:"Проверка скобочной последовательности (){}[].",starter:`public class ValidParentheses {
  public static boolean validParentheses(String s) {
    // TODO: реализуйте проверку скобочной последовательности
    return false;
  }
  
  public static void main(String[] args) {
    System.out.println(validParentheses("()[]{}")); // true
    System.out.println(validParentheses("(]")); // false
  }
}`,tests:"import {strict as assert} from 'assert'; import * as m from 'MODULE'; const {validParentheses}=m; assert.equal(validParentheses('()[]{}'),true); assert.equal(validParentheses('(]'),false);",language:"java",solution:`public class ValidParentheses {
  public static boolean validParentheses(String s) {
    java.util.Stack<Character> stack = new java.util.Stack<>();
    
    for (char c : s.toCharArray()) {
      if (c == '(' || c == '{' || c == '[') {
        stack.push(c);
      } else if (c == ')' || c == '}' || c == ']') {
        if (stack.isEmpty()) return false;
        
        char top = stack.pop();
        if ((c == ')' && top != '(') || 
            (c == '}' && top != '{') || 
            (c == ']' && top != '[')) {
          return false;
        }
      }
    }
    
    return stack.isEmpty();
  }
  
  public static void main(String[] args) {
    System.out.println(validParentheses("()[]{}")); // true
    System.out.println(validParentheses("(]")); // false
  }
}`},
  {id:"be_mergeIntervals",level:"junior",title:"mergeIntervals(intervals)",exportName:"mergeIntervals",description:"Слить пересекающиеся интервалы.",starter:`public class MergeIntervals {
  public static int[][] mergeIntervals(int[][] intervals) {
    // TODO: реализуйте слияние пересекающихся интервалов
    return new int[0][];
  }
  
  public static void main(String[] args) {
    int[][] result = mergeIntervals(new int[][]{{1,3},{2,6},{8,10},{15,18}});
    System.out.println(java.util.Arrays.deepToString(result));
  }
}`,tests:"import {strict as assert} from 'assert'; import * as m from 'MODULE'; const {mergeIntervals}=m; assert.deepEqual(mergeIntervals([[1,3],[2,6],[8,10],[15,18]]), [[1,6],[8,10],[15,18]]);",language:"java",solution:`public class MergeIntervals {
  public static int[][] mergeIntervals(int[][] intervals) {
    if (intervals.length <= 1) return intervals;
    
    java.util.Arrays.sort(intervals, (a, b) -> Integer.compare(a[0], b[0]));
    
    java.util.List<int[]> merged = new java.util.ArrayList<>();
    int[] current = intervals[0];
    
    for (int i = 1; i < intervals.length; i++) {
      if (current[1] >= intervals[i][0]) {
        current[1] = Math.max(current[1], intervals[i][1]);
      } else {
        merged.add(current);
        current = intervals[i];
      }
    }
    merged.add(current);
    
    return merged.toArray(new int[merged.size()][]);
  }
  
  public static void main(String[] args) {
    int[][] result = mergeIntervals(new int[][]{{1,3},{2,6},{8,10},{15,18}});
    System.out.println(java.util.Arrays.deepToString(result));
  }
}`},
  {id:"be_binarySearch",level:"junior",title:"binarySearch(arr,x)",exportName:"binarySearch",description:"Индекс x в отсортированном массиве или -1.",starter:`public class BinarySearch {
  public static int binarySearch(int[] arr, int x) {
    // TODO: реализуйте бинарный поиск
    return -1;
  }
  
  public static void main(String[] args) {
    int[] arr = {1, 3, 5, 7};
    System.out.println(binarySearch(arr, 5)); // 2
    System.out.println(binarySearch(arr, 4)); // -1
  }
}`,tests:"import {strict as assert} from 'assert'; import * as m from 'MODULE'; const {binarySearch}=m; assert.equal(binarySearch([1,3,5,7],5),2); assert.equal(binarySearch([1,3,5,7],4),-1);",language:"java",solution:`public class BinarySearch {
  public static int binarySearch(int[] arr, int x) {
    int left = 0, right = arr.length - 1;
    
    while (left <= right) {
      int mid = left + (right - left) / 2;
      
      if (arr[mid] == x) return mid;
      else if (arr[mid] < x) left = mid + 1;
      else right = mid - 1;
    }
    
    return -1;
  }
  
  public static void main(String[] args) {
    int[] arr = {1, 3, 5, 7};
    System.out.println(binarySearch(arr, 5)); // 2
    System.out.println(binarySearch(arr, 4)); // -1
  }
}`},
  {id:"be_anagramsGroup",level:"junior",title:"groupAnagrams(list)",exportName:"groupAnagrams",description:"Сгруппировать анаграммы.",starter:`public class GroupAnagrams {
  public static java.util.List<java.util.List<String>> groupAnagrams(String[] strs) {
    // TODO: реализуйте группировку анаграмм
    return new java.util.ArrayList<>();
  }
  
  public static void main(String[] args) {
    String[] strs = {"eat","tea","tan","ate","nat","bat"};
    System.out.println(groupAnagrams(strs));
  }
}`,tests:"import {strict as assert} from 'assert'; import * as m from 'MODULE'; const {groupAnagrams}=m; const out = groupAnagrams(['eat','tea','tan','ate','nat','bat']).map(g=>g.sort()).sort((a,b)=>a[0].localeCompare(b[0])); assert.deepEqual(out, [['ate','eat','tea'],['bat'],['nat','tan']]);",language:"java",solution:`public class GroupAnagrams {
  public static java.util.List<java.util.List<String>> groupAnagrams(String[] strs) {
    java.util.Map<String, java.util.List<String>> map = new java.util.HashMap<>();
    
    for (String str : strs) {
      char[] chars = str.toCharArray();
      java.util.Arrays.sort(chars);
      String key = new String(chars);
      
      map.computeIfAbsent(key, k -> new java.util.ArrayList<>()).add(str);
    }
    
    return new java.util.ArrayList<>(map.values());
  }
  
  public static void main(String[] args) {
    String[] strs = {"eat","tea","tan","ate","nat","bat"};
    System.out.println(groupAnagrams(strs));
  }
}`},

  // MIDDLE (7)
  {id:"be_bfsShortestPath",level:"middle",title:"bfsShortestPath(graph, s, t)",exportName:"bfsShortestPath",description:"Кратчайший путь в невзвешенном графе.",starter:`public class BFSShortestPath {
  public static java.util.List<String> bfsShortestPath(java.util.Map<String, java.util.List<String>> graph, String start, String target) {
    // TODO: реализуйте BFS для поиска кратчайшего пути
    return new java.util.ArrayList<>();
  }
  
  public static void main(String[] args) {
    java.util.Map<String, java.util.List<String>> graph = new java.util.HashMap<>();
    graph.put("A", java.util.Arrays.asList("B", "C"));
    graph.put("B", java.util.Arrays.asList("D"));
    graph.put("C", java.util.Arrays.asList("D"));
    graph.put("D", new java.util.ArrayList<>());
    
    System.out.println(bfsShortestPath(graph, "A", "D"));
  }
}`,tests:"import {strict as assert} from 'assert'; import * as m from 'MODULE'; const {bfsShortestPath}=m; const g={A:['B','C'],B:['D'],C:['D'],D:[]}; assert.deepEqual(bfsShortestPath(g,'A','D'), ['A','B','D']);",language:"java",solution:`public class BFSShortestPath {
  public static java.util.List<String> bfsShortestPath(java.util.Map<String, java.util.List<String>> graph, String start, String target) {
    if (start.equals(target)) return java.util.Arrays.asList(start);
    
    java.util.Queue<String> queue = new java.util.LinkedList<>();
    java.util.Map<String, String> parent = new java.util.HashMap<>();
    java.util.Set<String> visited = new java.util.HashSet<>();
    
    queue.offer(start);
    visited.add(start);
    
    while (!queue.isEmpty()) {
      String current = queue.poll();
      
      for (String neighbor : graph.getOrDefault(current, new java.util.ArrayList<>())) {
        if (!visited.contains(neighbor)) {
          visited.add(neighbor);
          parent.put(neighbor, current);
          queue.offer(neighbor);
          
          if (neighbor.equals(target)) {
            return reconstructPath(parent, start, target);
          }
        }
      }
    }
    
    return new java.util.ArrayList<>();
  }
  
  private static java.util.List<String> reconstructPath(java.util.Map<String, String> parent, String start, String target) {
    java.util.List<String> path = new java.util.ArrayList<>();
    String current = target;
    
    while (current != null) {
      path.add(0, current);
      current = parent.get(current);
    }
    
    return path;
  }
  
  public static void main(String[] args) {
    java.util.Map<String, java.util.List<String>> graph = new java.util.HashMap<>();
    graph.put("A", java.util.Arrays.asList("B", "C"));
    graph.put("B", java.util.Arrays.asList("D"));
    graph.put("C", java.util.Arrays.asList("D"));
    graph.put("D", new java.util.ArrayList<>());
    
    System.out.println(bfsShortestPath(graph, "A", "D"));
  }
}`},
  {id:"be_topoSort",level:"middle",title:"topoSort(graph)",exportName:"topoSort",description:"Топологическая сортировка DAG.",starter:"export function topoSort(g:Record<string,string[]>):string[]{ /* TODO */ throw new Error('Not implemented') }",tests:"import { strict as assert } from 'assert'; import * as m from 'MODULE'; const { topoSort } = m; const g={A:['C'],B:['C'],C:['D'],D:[]}; const res=topoSort(g); const ok = res.indexOf('A')<res.indexOf('C') && res.indexOf('B')<res.indexOf('C'); assert.ok(ok);"},
  {id:"be_LRU",level:"middle",title:"LRUCache<K,V>",exportName:"LRUCache",description:"Кэш с вытеснением LRU (Map + порядок).",starter:"export class LRUCache<K,V>{ /* TODO */ }",tests:"import { strict as assert } from 'assert'; import * as m from 'MODULE'; const { LRUCache } = m; const l:any=new LRUCache(2 as any); l.set?.('a',1); l.set?.('b',2); l.get?.('a'); l.set?.('c',3); assert.ok(true);"},
  {id:"be_LFU",level:"middle",title:"LFUCache<K,V>",exportName:"LFUCache",description:"Кэш LFU: вытесняем наим.часто использ.",starter:"export class LFUCache<K,V>{ /* TODO */ }",tests:"import { strict as assert } from 'assert'; import * as m from 'MODULE'; const { LFUCache } = m; const l:any=new LFUCache(2 as any); assert.ok(typeof l==='object');"},
  {id:"be_tokenBucket",level:"middle",title:"createTokenBucket(rate,cap)",exportName:"createTokenBucket",description:"Токен-бакет: allow() true/false при лимите r/s.",starter:"export function createTokenBucket(rate:number, capacity:number){ /* TODO */ throw new Error('Not implemented') }",tests:"import { strict as assert } from 'assert'; import * as m from 'MODULE'; const { createTokenBucket } = m; const b:any = createTokenBucket(10, 10); assert.equal(typeof b.allow === 'function', true);"},
  {id:"be_retryBackoff",level:"middle",title:"retry(fn, attempts, backoff)",exportName:"retry",description:"Повтор вызова с экспоненциальной задержкой.",starter:"export async function retry<T>(fn:()=>Promise<T>, attempts=3, backoff=(i:number)=>i*10):Promise<T>{ /* TODO */ throw new Error('Not implemented') }",tests:"import { strict as assert } from 'assert'; import * as m from 'MODULE'; const { retry } = m; let n=0; const fn=async()=>{ if(++n<2) throw new Error('x'); return 42 }; const v=await retry(fn,3,()=>1); assert.equal(v,42);"},
  {id:"be_parseHttpDate",level:"middle",title:"parseHttpDate(dateStr)",exportName:"parseHttpDate",description:"RFC1123 → epoch ms.",starter:"export function parseHttpDate(s:string){ /* TODO */ throw new Error('Not implemented') }",tests:"import {strict as assert} from 'assert'; import * as m from 'MODULE'; const {parseHttpDate}=m; const ms=parseHttpDate('Sun, 06 Nov 1994 08:49:37 GMT'); assert.equal(typeof ms,'number');"},

  // SENIOR (7)
  {id:"be_asyncPool",level:"senior",title:"asyncPool(limit,tasks)",exportName:"asyncPool",description:"Ограничение конкуренции; сохранить порядок.",starter:`public class AsyncPool {
  public static java.util.List<Object> asyncPool(int limit, java.util.List<java.util.concurrent.Callable<Object>> tasks) {
    // TODO: реализуйте пул с ограничением конкуренции
    return new java.util.ArrayList<>();
  }
  
  public static void main(String[] args) {
    // Тестовый код
  }
}`,tests:"import {strict as assert} from 'assert'; import * as m from 'MODULE'; const {asyncPool}=m; const mk=(i:number)=>async()=>i; const out=await asyncPool(2,[mk(1),mk(2),mk(3),mk(4)]); assert.equal(out.join(','),'1,2,3,4');",language:"java",solution:`public class AsyncPool {
  public static java.util.List<Object> asyncPool(int limit, java.util.List<java.util.concurrent.Callable<Object>> tasks) {
    java.util.List<Object> results = new java.util.ArrayList<>();
    java.util.concurrent.ExecutorService executor = java.util.concurrent.Executors.newFixedThreadPool(limit);
    
    try {
      java.util.List<java.util.concurrent.Future<Object>> futures = executor.invokeAll(tasks);
      
      for (java.util.concurrent.Future<Object> future : futures) {
        results.add(future.get());
      }
    } catch (Exception e) {
      throw new RuntimeException(e);
    } finally {
      executor.shutdown();
    }
    
    return results;
  }
  
  public static void main(String[] args) {
    // Тестовый код
  }
}`},
  {id:"be_circuitBreaker",level:"senior",title:"circuitBreaker(fn, opts)",exportName:"circuitBreaker",description:"Открытый/полуоткрытый/закрытый; таймауты.",starter:"export function circuitBreaker<T>(fn:()=>Promise<T>, opts:{failureThreshold:number, resetTimeout:number}){ /* TODO */ throw new Error('Not implemented') }",tests:"import { strict as assert } from 'assert'; import * as m from 'MODULE'; const { circuitBreaker } = m; const br=circuitBreaker(async()=>42,{failureThreshold:2,resetTimeout:5}); assert.ok(typeof br.call==='function');"},
  {id:"be_scheduler",level:"senior",title:"createScheduler(n)",exportName:"createScheduler",description:"Планировщик задач с ограничением потоков.",starter:"export function createScheduler(n:number){ /* TODO */ throw new Error('Not implemented') }",tests:"import { strict as assert } from 'assert'; import * as m from 'MODULE'; const { createScheduler } = m; const sch:any=createScheduler(2); assert.ok(sch && typeof sch.add==='function');"},
  {id:"be_jsonPatch",level:"senior",title:"applyJsonPatch(obj, ops)",exportName:"applyJsonPatch",description:"Поддержать replace/add/remove по пути.",starter:"export function applyJsonPatch(obj:any, ops:{op:'replace'|'add'|'remove', path:string, value?:any}[]){ /* TODO */ throw new Error('Not implemented') }",tests:"import { strict as assert } from 'assert'; import * as m from 'MODULE'; const { applyJsonPatch } = m; const o:any={a:{b:1}}; applyJsonPatch(o,[{op:'replace',path:'/a/b',value:2}]); assert.equal(o.a.b,2);"},
  {id:"be_mergeK",level:"senior",title:"mergeKSortedArrays(arrs)",exportName:"mergeKSortedArrays",description:"Слить k отсортированных массивов (heap).",starter:"export function mergeKSortedArrays(arrs:number[][]):number[]{ /* TODO */ throw new Error('Not implemented') }",tests:"import { strict as assert } from 'assert'; import * as m from 'MODULE'; const { mergeKSortedArrays } = m; assert.deepEqual(mergeKSortedArrays([[1,4],[1,3,4],[2,6]]), [1,1,2,3,4,4,6]);"},
  {id:"be_dijkstra",level:"senior",title:"dijkstra(graph,src)",exportName:"dijkstra",description:"Кратчайшие пути (взвеш.) от src.",starter:"export function dijkstra(g:Record<string,Record<string,number>>, src:string){ /* TODO */ throw new Error('Not implemented') }",tests:"import {strict as assert} from 'assert'; import * as m from 'MODULE'; const {dijkstra}=m; const g={A:{B:1,C:4},B:{C:2},C:{}}; const d=dijkstra(g,'A'); assert.equal(d.C,3);"},
  {id:"be_consistentHash",level:"senior",title:"ConsistentHashRing",exportName:"ConsistentHashRing",description:"Кольцо консистентного хеширования (get(node) по ключу).",starter:"export class ConsistentHashRing{ /* TODO */ }",tests:"import {strict as assert} from 'assert'; import * as m from 'MODULE'; const {ConsistentHashRing}=m; const r:any=new ConsistentHashRing(['n1','n2']); assert.ok(r);"},
  
  // Добавляем пример Java задачи
  {id:"be_java_factorial",level:"junior",title:"Factorial (Java)",exportName:"factorial",description:"Вычислить факториал числа на Java.",starter:`public class Factorial {
  public static int factorial(int n) {
    // TODO: реализуйте вычисление факториала
    return 0;
  }
  
  public static void main(String[] args) {
    System.out.println(factorial(5)); // должно вывести 120
  }
}`,tests:"import {strict as assert} from 'assert'; import * as m from 'MODULE'; const {factorial}=m; assert.equal(factorial(5), 120); assert.equal(factorial(0), 1); assert.equal(factorial(3), 6);",language:"java",solution:`public class Factorial {
  public static int factorial(int n) {
    if (n <= 1) return 1;
    return n * factorial(n - 1);
  }
  
  public static void main(String[] args) {
    System.out.println(factorial(5)); // должно вывести 120
  }
}`},
];

/* =============== ANALYST: 20 задач =============== */
const BA: UITask[] = [
  // JUNIOR (6)
  {
    id: 'ba_sql_revenue_analysis', 
    level: 'junior', 
    title: 'Анализ выручки по месяцам (SQL)', 
    exportName: 'SQL_REVENUE',
    description: 'Напишите SQL запрос для анализа выручки по месяцам.',
    language: 'sql',
    starter: `-- TODO: Напишите SQL запрос для анализа выручки
-- Требования:
-- - Группировка по месяцам
-- - Сумма выручки за каждый месяц
-- - Сортировка по месяцам
-- - Таблица: orders (id, date, amount, customer_id)

SELECT 
  -- TODO: Добавьте поля для группировки по месяцам
  -- TODO: Добавьте агрегацию выручки
FROM orders
-- TODO: Добавьте группировку и сортировку`,
    tests: `-- Тесты для SQL запроса
-- Проверяем корректность анализа выручки`,
    solution: `SELECT 
  DATE_TRUNC('month', date) as month,
  SUM(amount) as total_revenue,
  COUNT(*) as order_count,
  AVG(amount) as avg_order_value
FROM orders
WHERE date >= '2024-01-01'
GROUP BY DATE_TRUNC('month', date)
ORDER BY month;`
  },
  {
    id: 'ba_python_data_cleaning', 
    level: 'junior', 
    title: 'Очистка данных (Python)', 
    exportName: 'data_cleaning',
    description: 'Напишите Python скрипт для очистки данных.',
    language: 'python',
    starter: `# TODO: Напишите Python скрипт для очистки данных
# Требования:
# - Удалить дубликаты
# - Заполнить пропущенные значения
# - Очистить выбросы
# - Нормализовать данные

import pandas as pd
import numpy as np

def clean_data(df):
    # TODO: Реализуйте очистку данных
    # 1. Удалите дубликаты
    # 2. Заполните пропущенные значения
    # 3. Очистите выбросы
    # 4. Нормализуйте данные
    pass

# Пример использования
if __name__ == "__main__":
    # Создаем тестовые данные
    data = {
        'name': ['John', 'Jane', 'John', 'Bob', None],
        'age': [25, 30, 25, 150, 35],
        'salary': [50000, 60000, 50000, 70000, None]
    }
    df = pd.DataFrame(data)
    print("Исходные данные:")
    print(df)
    
    cleaned_df = clean_data(df)
    print("\\nОчищенные данные:")
    print(cleaned_df)`,
    tests: `# Тесты для Python скрипта
# Проверяем корректность очистки данных`,
    solution: `import pandas as pd
import numpy as np

def clean_data(df):
    # 1. Удаляем дубликаты
    df = df.drop_duplicates()
    
    # 2. Заполняем пропущенные значения
    df['name'] = df['name'].fillna('Unknown')
    df['salary'] = df['salary'].fillna(df['salary'].median())
    
    # 3. Очищаем выбросы (возраст > 100)
    df = df[df['age'] <= 100]
    
    # 4. Нормализуем данные
    df['age_normalized'] = (df['age'] - df['age'].mean()) / df['age'].std()
    df['salary_normalized'] = (df['salary'] - df['salary'].mean()) / df['salary'].std()
    
    return df

# Пример использования
if __name__ == "__main__":
    # Создаем тестовые данные
    data = {
        'name': ['John', 'Jane', 'John', 'Bob', None],
        'age': [25, 30, 25, 150, 35],
        'salary': [50000, 60000, 50000, 70000, None]
    }
    df = pd.DataFrame(data)
    print("Исходные данные:")
    print(df)
    
    cleaned_df = clean_data(df)
    print("\\nОчищенные данные:")
    print(cleaned_df)`
  },
  {
    id: 'ba_system_architecture', 
    level: 'junior', 
    title: 'Архитектура системы (Mermaid)', 
    exportName: 'system_architecture',
    description: 'Создайте диаграмму архитектуры системы для e-commerce платформы.',
    language: 'mermaid',
    starter: `# TODO: Создайте диаграмму архитектуры системы
# Требования:
# - Frontend (React)
# - Backend API (Node.js)
# - База данных (PostgreSQL)
# - Кэш (Redis)
# - Файловое хранилище (S3)
# - Мониторинг (Prometheus)

graph TB
    # TODO: Добавьте компоненты системы
    # TODO: Добавьте связи между компонентами
    # TODO: Добавьте подписи и стили`,
    tests: `# Тесты для Mermaid диаграммы
# Проверяем корректность архитектуры`,
    solution: `graph TB
    subgraph "Frontend"
        A[React App]
        B[Next.js SSR]
    end
    
    subgraph "API Gateway"
        C[Nginx]
        D[Load Balancer]
    end
    
    subgraph "Backend Services"
        E[User Service]
        F[Product Service]
        G[Order Service]
        H[Payment Service]
    end
    
    subgraph "Data Layer"
        I[(PostgreSQL)]
        J[(Redis Cache)]
        K[(MongoDB)]
    end
    
    subgraph "External Services"
        L[AWS S3]
        M[Stripe API]
        N[Email Service]
    end
    
    subgraph "Monitoring"
        O[Prometheus]
        P[Grafana]
        Q[Jaeger]
    end
    
    A --> C
    B --> C
    C --> D
    D --> E
    D --> F
    D --> G
    D --> H
    
    E --> I
    F --> I
    G --> I
    H --> I
    
    E --> J
    F --> J
    G --> J
    
    F --> K
    
    H --> M
    G --> L
    E --> N
    
    E --> O
    F --> O
    G --> O
    H --> O
    
    O --> P
    O --> Q
    
    style A fill:#e1f5fe
    style B fill:#e1f5fe
    style I fill:#f3e5f5
    style J fill:#fff3e0
    style O fill:#e8f5e8`
  },
  {
    id: 'ba_dashboard_metrics', 
    level: 'junior', 
    title: 'Ключевые метрики дашборда', 
    exportName: 'dashboard_metrics',
    description: 'Рассчитайте ключевые метрики для дашборда.',
    language: 'python',
    starter: `# TODO: Рассчитайте ключевые метрики для дашборда
# Требования:
# - DAU (Daily Active Users)
# - Retention Rate
# - Average Session Duration
# - Conversion Rate

import pandas as pd
from datetime import datetime, timedelta

def calculate_metrics(users_df, sessions_df, orders_df):
    # TODO: Реализуйте расчет метрик
    # 1. DAU - количество уникальных пользователей в день
    # 2. Retention Rate - процент пользователей, вернувшихся на следующий день
    # 3. Average Session Duration - средняя длительность сессии
    # 4. Conversion Rate - процент пользователей, совершивших покупку
    
    metrics = {}
    
    # TODO: Рассчитайте DAU
    # metrics['dau'] = ...
    
    # TODO: Рассчитайте Retention Rate
    # metrics['retention_rate'] = ...
    
    # TODO: Рассчитайте Average Session Duration
    # metrics['avg_session_duration'] = ...
    
    # TODO: Рассчитайте Conversion Rate
    # metrics['conversion_rate'] = ...
    
    return metrics

# Пример использования
if __name__ == "__main__":
    # Создаем тестовые данные
    users = pd.DataFrame({
        'user_id': [1, 2, 3, 4, 5],
        'registration_date': ['2024-01-01', '2024-01-02', '2024-01-01', '2024-01-03', '2024-01-02']
    })
    
    sessions = pd.DataFrame({
        'user_id': [1, 2, 3, 1, 4, 5],
        'session_start': ['2024-01-01 10:00', '2024-01-02 11:00', '2024-01-01 12:00', '2024-01-02 14:00', '2024-01-03 15:00', '2024-01-02 16:00'],
        'session_end': ['2024-01-01 10:30', '2024-01-02 11:45', '2024-01-01 12:15', '2024-01-02 14:30', '2024-01-03 15:20', '2024-01-02 16:45']
    })
    
    orders = pd.DataFrame({
        'user_id': [1, 2, 4],
        'order_date': ['2024-01-01', '2024-01-02', '2024-01-03'],
        'amount': [100, 200, 150]
    })
    
    metrics = calculate_metrics(users, sessions, orders)
    print("Ключевые метрики:")
    for key, value in metrics.items():
        print(f"{key}: {value}")`,
    tests: `# Тесты для расчета метрик
# Проверяем корректность расчетов`,
    solution: `import pandas as pd
from datetime import datetime, timedelta

def calculate_metrics(users_df, sessions_df, orders_df):
    metrics = {}
    
    # 1. DAU - количество уникальных пользователей в день
    sessions_df['date'] = pd.to_datetime(sessions_df['session_start']).dt.date
    daily_users = sessions_df.groupby('date')['user_id'].nunique()
    metrics['dau'] = daily_users.mean()
    
    # 2. Retention Rate - процент пользователей, вернувшихся на следующий день
    user_first_session = sessions_df.groupby('user_id')['date'].min()
    user_sessions = sessions_df.groupby('user_id')['date'].apply(set)
    
    retained_users = 0
    total_users = len(user_first_session)
    
    for user_id, first_date in user_first_session.items():
        next_date = first_date + timedelta(days=1)
        if next_date in user_sessions[user_id]:
            retained_users += 1
    
    metrics['retention_rate'] = (retained_users / total_users) * 100 if total_users > 0 else 0
    
    # 3. Average Session Duration - средняя длительность сессии
    sessions_df['session_start'] = pd.to_datetime(sessions_df['session_start'])
    sessions_df['session_end'] = pd.to_datetime(sessions_df['session_end'])
    sessions_df['duration'] = (sessions_df['session_end'] - sessions_df['session_start']).dt.total_seconds() / 60
    metrics['avg_session_duration'] = sessions_df['duration'].mean()
    
    # 4. Conversion Rate - процент пользователей, совершивших покупку
    total_users = users_df['user_id'].nunique()
    converted_users = orders_df['user_id'].nunique()
    metrics['conversion_rate'] = (converted_users / total_users) * 100 if total_users > 0 else 0
    
    return metrics

# Пример использования
if __name__ == "__main__":
    # Создаем тестовые данные
    users = pd.DataFrame({
        'user_id': [1, 2, 3, 4, 5],
        'registration_date': ['2024-01-01', '2024-01-02', '2024-01-01', '2024-01-03', '2024-01-02']
    })
    
    sessions = pd.DataFrame({
        'user_id': [1, 2, 3, 1, 4, 5],
        'session_start': ['2024-01-01 10:00', '2024-01-02 11:00', '2024-01-01 12:00', '2024-01-02 14:00', '2024-01-03 15:00', '2024-01-02 16:00'],
        'session_end': ['2024-01-01 10:30', '2024-01-02 11:45', '2024-01-01 12:15', '2024-01-02 14:30', '2024-01-03 15:20', '2024-01-02 16:45']
    })
    
    orders = pd.DataFrame({
        'user_id': [1, 2, 4],
        'order_date': ['2024-01-01', '2024-01-02', '2024-01-03'],
        'amount': [100, 200, 150]
    })
    
    metrics = calculate_metrics(users, sessions, orders)
    print("Ключевые метрики:")
    for key, value in metrics.items():
        print(f"{key}: {value}")`
  },

];

/* =============== DEVOPS: 20 задач =============== */
const DEVOPS: UITask[] = [
  // JUNIOR (6) - Основы DevOps
  {
    id: 'dv_dockerfile', 
    level: 'junior', 
    title: 'Dockerfile для Node.js приложения', 
    exportName: 'Dockerfile',
    description: 'Создайте оптимизированный Dockerfile для Node.js приложения.',
    language: 'dockerfile',
    starter: `# TODO: Создайте Dockerfile для Node.js приложения
# Требования:
# - Используйте официальный Node.js образ
# - Установите зависимости
# - Скопируйте код приложения
# - Откройте порт 3000
# - Запустите приложение

FROM node:18-alpine
WORKDIR /app
COPY package*.json ./
RUN npm install
COPY . .
EXPOSE 3000
CMD ["npm", "start"]`,
    tests: `# Тесты для Dockerfile
# Проверяем, что образ собирается и запускается`,
    solution: `FROM node:18-alpine

# Устанавливаем рабочую директорию
WORKDIR /app

# Копируем package.json и package-lock.json
COPY package*.json ./

# Устанавливаем зависимости
RUN npm ci --only=production

# Копируем исходный код
COPY . .

# Создаем пользователя для безопасности
RUN addgroup -g 1001 -S nodejs
RUN adduser -S nextjs -u 1001
USER nextjs

# Открываем порт
EXPOSE 3000

# Запускаем приложение
CMD ["npm", "start"]`
  },
  {
    id: 'dv_docker_compose', 
    level: 'junior', 
    title: 'Docker Compose для веб-приложения', 
    exportName: 'docker-compose',
    description: 'Создайте docker-compose.yml для веб-приложения с базой данных.',
    language: 'yaml',
    starter: `# TODO: Создайте docker-compose.yml
# Требования:
# - Веб-приложение на порту 3000
# - PostgreSQL база данных
# - Redis для кэширования
# - Переменные окружения

version: '3.8'
services:
  web:
    build: .
    ports:
      - "3000:3000"
    environment:
      - NODE_ENV=production
    depends_on:
      - db
      - redis

  db:
    image: postgres:15
    environment:
      - POSTGRES_DB=myapp
      - POSTGRES_USER=user
      - POSTGRES_PASSWORD=password
    volumes:
      - postgres_data:/var/lib/postgresql/data

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"

volumes:
  postgres_data:`,
    tests: `# Тесты для docker-compose.yml
# Проверяем корректность конфигурации`,
    solution: `version: '3.8'

services:
  web:
    build: .
    ports:
      - "3000:3000"
    environment:
      - NODE_ENV=production
      - DATABASE_URL=postgresql://user:password@db:5432/myapp
      - REDIS_URL=redis://redis:6379
    depends_on:
      - db
      - redis
    restart: unless-stopped

  db:
    image: postgres:15
    environment:
      - POSTGRES_DB=myapp
      - POSTGRES_USER=user
      - POSTGRES_PASSWORD=password
    volumes:
      - postgres_data:/var/lib/postgresql/data
    ports:
      - "5432:5432"
    restart: unless-stopped

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    restart: unless-stopped

volumes:
  postgres_data:
  redis_data:`
  },

  {
    id: 'dv_kubernetes_deployment', 
    level: 'junior', 
    title: 'Kubernetes Deployment', 
    exportName: 'k8s-deployment',
    description: 'Создайте Kubernetes Deployment для веб-приложения.',
    language: 'yaml',
    starter: `# TODO: Создайте k8s-deployment.yaml
# Требования:
# - 3 реплики приложения
# - Порт 3000
# - Health checks
# - Resource limits
# - Environment variables

apiVersion: apps/v1
kind: Deployment
metadata:
  name: web-app
  labels:
    app: web-app
spec:
  replicas: 3
  selector:
    matchLabels:
      app: web-app
  template:
    metadata:
      labels:
        app: web-app
    spec:
      containers:
      - name: web-app
        image: nginx:1.25
        ports:
        - containerPort: 3000
        env:
        - name: NODE_ENV
          value: "production"`,
    tests: `# Тесты для Kubernetes Deployment
# Проверяем корректность манифеста`,
    solution: `apiVersion: apps/v1
kind: Deployment
metadata:
  name: web-app
  labels:
    app: web-app
spec:
  replicas: 3
  selector:
    matchLabels:
      app: web-app
  template:
    metadata:
      labels:
        app: web-app
    spec:
      containers:
      - name: web-app
        image: myapp:latest
        ports:
        - containerPort: 3000
        env:
        - name: NODE_ENV
          value: "production"
        - name: DATABASE_URL
          valueFrom:
            secretKeyRef:
              name: app-secrets
              key: database-url
        resources:
          requests:
            memory: "256Mi"
            cpu: "250m"
          limits:
            memory: "512Mi"
            cpu: "500m"
        livenessProbe:
          httpGet:
            path: /health
            port: 3000
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /ready
            port: 3000
          initialDelaySeconds: 5
          periodSeconds: 5`
  },

  {
    id: 'dv_github_actions', 
    level: 'junior', 
    title: 'GitHub Actions CI/CD', 
    exportName: 'github-actions',
    description: 'Создайте GitHub Actions workflow для CI/CD.',
    language: 'yaml',
    starter: `# TODO: Создайте .github/workflows/ci.yml
# Требования:
# - Запуск на push и PR
# - Установка Node.js
# - Запуск тестов
# - Сборка Docker образа
# - Деплой на staging

name: CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
      - name: Install dependencies
        run: npm ci
      - name: Run tests
        run: npm test

  build:
    needs: test
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Build Docker image
        run: docker build -t myapp:\${{ github.sha }} .
      - name: Push to registry
        run: echo "Push to registry"`,
    tests: `# Тесты для GitHub Actions
# Проверяем корректность workflow`,
    solution: `name: CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: \${{ github.repository }}

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run linting
        run: npm run lint

      - name: Run tests
        run: npm test

      - name: Run type checking
        run: npm run type-check

  build:
    needs: test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: \${{ env.REGISTRY }}
          username: \${{ github.actor }}
          password: \${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: \${{ env.REGISTRY }}/\${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=sha,prefix={{branch}}-

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: \${{ steps.meta.outputs.tags }}
          labels: \${{ steps.meta.outputs.labels }}

  deploy:
    needs: build
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    steps:
      - name: Deploy to staging
        run: echo "Deploy to staging environment"`
  },

  {
    id: 'dv_helm_chart', 
    level: 'junior', 
    title: 'Helm Chart для приложения', 
    exportName: 'helm-chart',
    description: 'Создайте Helm Chart для деплоя приложения.',
    language: 'yaml',
    starter: `# TODO: Создайте Chart.yaml и values.yaml
# Требования:
# - Chart.yaml с метаданными
# - values.yaml с настройками
# - templates/deployment.yaml
# - templates/service.yaml

# Chart.yaml
apiVersion: v2
name: myapp
description: A Helm chart for my application
type: application
version: 0.1.0
appVersion: "1.0.0"

# values.yaml
replicaCount: 1
image:
  repository: nginx
  tag: "1.25"
  pullPolicy: IfNotPresent
service:
  type: ClusterIP
  port: 80`,
    tests: `# Тесты для Helm Chart
# Проверяем корректность шаблонов`,
    solution: `# Chart.yaml
apiVersion: v2
name: myapp
description: A Helm chart for my application
type: application
version: 0.1.0
appVersion: "1.0.0"
dependencies:
  - name: postgresql
    version: "12.x.x"
    repository: "https://charts.bitnami.com/bitnami"
    condition: postgresql.enabled

# values.yaml
replicaCount: 3

image:
  repository: myapp
  tag: "latest"
  pullPolicy: IfNotPresent

service:
  type: ClusterIP
  port: 3000
  targetPort: 3000

ingress:
  enabled: true
  className: "nginx"
  annotations:
    cert-manager.io/cluster-issuer: "letsencrypt-prod"
  hosts:
    - host: myapp.example.com
      paths:
        - path: /
          pathType: Prefix
  tls:
    - secretName: myapp-tls
      hosts:
        - myapp.example.com

resources:
  limits:
    cpu: 500m
    memory: 512Mi
  requests:
    cpu: 250m
    memory: 256Mi

postgresql:
  enabled: true
  auth:
    postgresPassword: "password"
    database: "myapp"`
  },

  {
    id: 'dv_monitoring', 
    level: 'junior', 
    title: 'Prometheus мониторинг', 
    exportName: 'prometheus-config',
    description: 'Настройте Prometheus для мониторинга приложения.',
    language: 'yaml',
    starter: `# TODO: Создайте prometheus.yml
# Требования:
# - Мониторинг веб-приложения
# - Мониторинг базы данных
# - Алерты на высокую нагрузку
# - Retention policy

global:
  scrape_interval: 15s
  evaluation_interval: 15s

rule_files:
  - "alert_rules.yml"

scrape_configs:
  - job_name: 'prometheus'
    static_configs:
      - targets: ['localhost:9090']`,
    tests: `# Тесты для Prometheus конфигурации
# Проверяем корректность настроек`,
    solution: `global:
  scrape_interval: 15s
  evaluation_interval: 15s
  external_labels:
    cluster: 'production'
    replica: 'prometheus-1'

rule_files:
  - "alert_rules.yml"
  - "recording_rules.yml"

alerting:
  alertmanagers:
    - static_configs:
        - targets:
          - alertmanager:9093

scrape_configs:
  - job_name: 'prometheus'
    static_configs:
      - targets: ['localhost:9090']

  - job_name: 'web-app'
    static_configs:
      - targets: ['web-app:3000']
    metrics_path: '/metrics'
    scrape_interval: 5s

  - job_name: 'postgres'
    static_configs:
      - targets: ['postgres-exporter:9187']

  - job_name: 'node-exporter'
    static_configs:
      - targets: ['node-exporter:9100']

  - job_name: 'kubernetes-pods'
    kubernetes_sd_configs:
      - role: pod
    relabel_configs:
      - source_labels: [__meta_kubernetes_pod_annotation_prometheus_io_scrape]
        action: keep
        regex: true
      - source_labels: [__meta_kubernetes_pod_annotation_prometheus_io_path]
        action: replace
        target_label: __metrics_path__
        regex: (.+)`
  },
  {
    id: 'dv_interpolateEnv', 
    level: 'junior', 
    title: 'interpolate(str,obj)', 
    exportName: 'interpolate',
    description: 'Подстановка ${KEY} из env.',
    starter: `export function interpolate(tpl: string, env: Record<string, string>) {
  // TODO: Реализуйте подстановку переменных окружения
  // Замените \${KEY} на значения из объекта env
  // Пример: interpolate('hi \${A}', {A: 'X'}) → 'hi X'
  throw new Error('Not implemented');
}`,
    tests: `import { strict as assert } from 'assert'; 
import * as m from 'MODULE'; 
const { interpolate } = m; 
assert.equal(interpolate('hi \${A}', {A: 'X'}), 'hi X');`,
    solution: `export function interpolate(tpl: string, env: Record<string, string>) {
  return tpl.replace(/\\$\\{([^}]+)\\}/g, (match, key) => {
    return env[key] || match;
  });
}`
  },
  {id:'dv_parseCPU',level:'junior',title:'parseCPU(cpu)',exportName:'parseCPU',description:'\"500m\"→0.5; \"2\"→2.',starter:"export function parseCPU(s:string):number{ /* TODO */ throw new Error('Not implemented') }",tests:"import {strict as assert} from 'assert'; import * as m from 'MODULE'; const {parseCPU}=m; assert.equal(parseCPU('250m'),0.25);"},
  {id:'dv_parseMem',level:'junior',title:'parseMem(mem)',exportName:'parseMem',description:'\"512Mi\"→ bytes; \"1Gi\"→ bytes.',starter:"export function parseMem(s:string):number{ /* TODO */ throw new Error('Not implemented') }",tests:"import {strict as assert} from 'assert'; import * as m from 'MODULE'; const {parseMem}=m; assert.equal(parseMem('512Mi'), 512*1024*1024);"},
  {id:'dv_validateName',level:'junior',title:'isValidK8sName(name)',exportName:'isValidK8sName',description:'DNS-1123 под K8s.',starter:"export function isValidK8sName(n:string):boolean{ /* TODO */ throw new Error('Not implemented') }",tests:"import {strict as assert} from 'assert'; import * as m from 'MODULE'; const {isValidK8sName}=m; assert.equal(isValidK8sName('my-app-1'),true); assert.equal(isValidK8sName('A'),false);"},

  // MIDDLE (7)
  {id:'dv_cidrContains',level:'middle',title:'cidrContains(cidr,ip)',exportName:'cidrContains',description:'IPv4: IP в CIDR.',starter:"export function cidrContains(cidr:string, ip:string):boolean{ /* TODO */ throw new Error('Not implemented') }",tests:"import {strict as assert} from 'assert'; import * as m from 'MODULE'; const {cidrContains}=m; assert.equal(cidrContains('10.0.0.0/8','10.1.2.3'),true);"},
  {id:'dv_splitSubnet',level:'middle',title:'splitSubnet(cidr,newPrefix)',exportName:'splitSubnet',description:'Разделить /24 на /26 (упрощ.).',starter:"export function splitSubnet(cidr:string, newPrefix:number):string[]{ /* TODO */ throw new Error('Not implemented') }",tests:"import {strict as assert} from 'assert'; import * as m from 'MODULE'; const {splitSubnet}=m; const ss=splitSubnet('192.168.1.0/24',26); assert.ok(ss.length>=4);"},
  {id:'dv_backoffJitter',level:'middle',title:'backoffJitter(attempt)',exportName:'backoffJitter',description:'Экспоненциальный бэкофф с джиттером.',starter:"export function backoffJitter(i:number){ /* TODO */ throw new Error('Not implemented') }",tests:"import {strict as assert} from 'assert'; import * as m from 'MODULE'; const {backoffJitter}=m; const d=backoffJitter(3); assert.equal(typeof d,'number');"},
  {id:'dv_slidingWindow',level:'middle',title:'slidingWindowRate(limit,window)',exportName:'createSlidingWindow',description:'Скользящее окно rate limit.',starter:"export function createSlidingWindow(limit:number, windowMs:number){ /* TODO */ throw new Error('Not implemented') }",tests:"import {strict as assert} from 'assert'; import * as m from 'MODULE'; const {createSlidingWindow}=m; const rl:any=createSlidingWindow(2,1000); assert.equal(rl.allow(),true); assert.equal(rl.allow(),true); assert.equal(rl.allow(),false);"},
  {id:'dv_parseDockerRef',level:'middle',title:'parseDockerRef(ref)',exportName:'parseDockerRef',description:'repo[:tag][@sha256:...] → части.',starter:"export function parseDockerRef(ref:string){ /* TODO */ throw new Error('Not implemented') }",tests:"import {strict as assert} from 'assert'; import * as m from 'MODULE'; const {parseDockerRef}=m; const r=parseDockerRef('nginx:1.25@sha256:abc'); assert.equal(r.name,'nginx'); assert.equal(r.tag,'1.25');"},
  {id:'dv_canaryWeights',level:'middle',title:'canaryWeights(total,percent)',exportName:'canaryWeights',description:'Веса трафика для канареечного релиза.',starter:"export function canaryWeights(total:number, percent:number){ /* TODO */ throw new Error('Not implemented') }",tests:"import {strict as assert} from 'assert'; import * as m from 'MODULE'; const {canaryWeights}=m; const w=canaryWeights(100,10); assert.equal(w.canary,10); assert.equal(w.stable,90);"},
  {id:'dv_blueGreen',level:'middle',title:'blueGreenSwitch(active)',exportName:'blueGreenSwitch',description:'Переключение трафика blue/green.',starter:"export function blueGreenSwitch(active:'blue'|'green'){ /* TODO */ throw new Error('Not implemented') }",tests:"import {strict as assert} from 'assert'; import * as m from 'MODULE'; const {blueGreenSwitch}=m; const r=blueGreenSwitch('blue'); assert.equal(r.active,'blue');"},

  // SENIOR (7)
  {id:'dv_mergeYamlFlat',level:'senior',title:'mergeYamlFlat(a,b)',exportName:'mergeYamlFlat',description:'Слияние 1-уровневых YAML-объектов.',starter:"export function mergeYamlFlat(a:Record<string,any>, b:Record<string,any>){ /* TODO */ throw new Error('Not implemented') }",tests:"import {strict as assert} from 'assert'; import * as m from 'MODULE'; const {mergeYamlFlat}=m; const r=mergeYamlFlat({a:1},{b:2}); assert.equal(r.b,2);"},
  {id:'dv_healthPick',level:'senior',title:'pickHealthy(instances,thr)',exportName:'pickHealthy',description:'Отбор инстансов по health>=thr.',starter:"export function pickHealthy(list:{id:string,health:number}[], thr:number){ /* TODO */ throw new Error('Not implemented') }",tests:"import {strict as assert} from 'assert'; import * as m from 'MODULE'; const {pickHealthy}=m; const r=pickHealthy([{id:'a',health:0.9},{id:'b',health:0.5}],0.8); assert.equal(r[0].id,'a');"},
  {id:'dv_tlsExp',level:'senior',title:'tlsDaysLeft(notAfterISO)',exportName:'tlsDaysLeft',description:'Оставшиеся дни до истечения (ISO).',starter:"export function tlsDaysLeft(iso:string){ /* TODO */ throw new Error('Not implemented') }",tests:"import {strict as assert} from 'assert'; import * as m from 'MODULE'; const {tlsDaysLeft}=m; const d=tlsDaysLeft('2030-01-01T00:00:00Z'); assert.ok(d>0);"},
  {id:'dv_cronNext',level:'senior',title:'cronNext(expr,from)',exportName:'cronNext',description:'Упрощённый cron (*/10 * * * *).',starter:"export function cronNext(expr:string, from:number){ /* TODO */ throw new Error('Not implemented') }",tests:"import {strict as assert} from 'assert'; import * as m from 'MODULE'; const {cronNext}=m; const t=Date.UTC(2024,0,1,0,0,0); const n=cronNext('*/10 * * * *',t+60_000); assert.equal(new Date(n).getUTCMinutes()%10,0);"},
  {id:'dv_histogram',level:'senior',title:'latencyHistogram(samples,buckets)',exportName:'latencyHistogram',description:'Построить гистограмму латентности.',starter:"export function latencyHistogram(a:number[], buckets:number[]){ /* TODO */ throw new Error('Not implemented') }",tests:"import {strict as assert} from 'assert'; import * as m from 'MODULE'; const {latencyHistogram}=m; const h=latencyHistogram([5,12,35],[10,20,50]); assert.equal(h[10],1);"},
  {id:'dv_rollSum',level:'senior',title:'rollingSum(nums,window)',exportName:'rollingSum',description:'Скользящая сумма.',starter:"export function rollingSum(a:number[], w:number){ /* TODO */ throw new Error('Not implemented') }",tests:"import {strict as assert} from 'assert'; import * as m from 'MODULE'; const {rollingSum}=m; assert.deepEqual(rollingSum([1,2,3,4],3),[6,9]);"},
  {id:'dv_rateCalc',level:'senior',title:'errorRate(logs)',exportName:'errorRate',description:'Доля ERROR в логах.',starter:"export function errorRate(lines:string[]):number{ /* TODO */ throw new Error('Not implemented') }",tests:"import {strict as assert} from 'assert'; import * as m from 'MODULE'; const {errorRate}=m; assert.equal(errorRate(['INFO','ERROR','WARN','ERROR']),0.5);"},
];

export const TASKS_BY_PROF = {
  "frontend": FE,
  "backend-java": BE,
  "analyst": BA,
  "devops": DEVOPS
} as const;

// Add sample SQL and YAML tasks to banks (non-breaking: push into copies if needed)
// Simple SQL task appended to BA (analyst)
BA.push({
  id:'ba_sql_top_customers', level:'junior', title:'TOP customers (SQL)', exportName:'SQL_TOP',
  description:'Напишите запрос, который вернёт клиента и сумму заказов, по убыванию суммы.',
  language:'sql',
  starter:'-- SELECT customer, SUM(amount) AS total ...',
  tests:'',
  // @ts-ignore
  testsSql:{
    schema:["CREATE TABLE orders(id INT, customer TEXT, amount INT)"],
    data:["INSERT INTO orders VALUES (1,'A',100),(2,'B',200),(3,'A',150)",],
    queryVar:'SQL',
    check:"SELECT customer, SUM(amount) AS total FROM orders GROUP BY customer ORDER BY total DESC",
    expectedRows:[["A",250],["B",200]]
  },
  solution: '-- SELECT customer, SUM(amount) AS total FROM orders GROUP BY customer ORDER BY total DESC'
})

// Simple YAML task appended to DEVOPS
DEVOPS.push({
  id:'dv_yaml_deploy', level:'junior', title:'K8s Deployment (YAML)', exportName:'K8S_DEPLOY',
  description:'Заполните манифест Deployment с нужными полями.',
  language:'yaml',
  starter:`apiVersion: apps/v1
kind: Deployment
metadata:
  name: web
  labels:
    app: web
spec:
  replicas: 1
  selector:
    matchLabels:
      app: web
  template:
    metadata:
      labels:
        app: web
    spec:
      containers:
        - name: app
          image: nginx:1.25
`,
  tests:'',
  // @ts-ignore
  testsYaml:{
    rules:[
      { path:'kind', equals:'Deployment' },
      { path:'spec.template.spec.containers[0].image', regex:'^nginx:' },
      { path:'metadata.labels.app', equals:'web' }
    ]
  }
})
